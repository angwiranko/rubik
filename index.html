<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SCUBIK - Personalized Rubik's Cube</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
  <style>
    :root {
      --primary: #ff4081;
      --primary-dark: #c60055;
      --primary-light: #ff79b0;
      --secondary: #303F9F;
      --text-light: #ffffff;
      --text-dark: #212121;
      --background-dark: #121212;
      --surface: #1e1e1e;
      --surface-light: #2c2c2c;
      --surface-lighter: #383838;
      --cube-red: #f44336;
      --cube-blue: #2196f3;
      --cube-orange: #ff9800;
      --cube-coral: #ff6f61;
      --cube-white: #ffffff;
      --cube-yellow: #ffeb3b;
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.2);
      --transition: all 0.3s ease;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Rubik', sans-serif;
      background-color: var(--background-dark);
      color: var(--text-light);
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      z-index: 10;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
      pointer-events: none;
    }
  
    .header h1 {
      font-family: "Rubik", sans-serif;
      font-weight: 700;
      color: var(--text-light);
      margin: 0;
      font-size: 5rem;
      text-shadow: 0 0 15px rgba(255,64,129,0.5);
      letter-spacing: 2px;
      pointer-events: none;
    }

    .buttons {
      display: flex;
      flex-direction: row;
      gap: 12px;
      margin-top: 20px;
      pointer-events: auto;
    }

    .button {
      padding: 12px 16px;
      font-size: 1rem;
      border: none;
      border-radius: var(--radius-md);
      background-color: var(--surface-light);
      font-family: "Rubik", sans-serif;
      font-weight: 500;
      color: var(--text-light);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: var(--shadow);
    }
    
    .button:hover {
      background-color: var(--surface-lighter);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .button-primary {
      background-color: var(--primary);
      color: white;
    }

    .button-primary:hover {
      background-color: var(--primary-dark);
    }

    .button-icon {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .input-panel-toggle {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: 30px;
      padding: 12px 25px;
      font-size: 1.3rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: var(--shadow-lg);
      cursor: pointer;
      transition: var(--transition);
    }

    .input-panel-toggle:hover {
      background-color: var(--primary-dark);
      transform: translateX(-50%) translateY(-2px);
    }

    .input-wrapper {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      height: 0;
      background-color: var(--surface);
      border-top-left-radius: var(--radius-lg);
      border-top-right-radius: var(--radius-lg);
      transition: height 0.8s cubic-bezier(0.22, 1, 0.36, 1);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 1000;
      overflow: hidden;
      box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.3);
    }
    
    .input-wrapper.open {
      height: 70vh;
    }
    
    .input-header {
      width: 100%;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      border-bottom: 1px solid var(--surface-light);
      margin-bottom: 20px;
    }
    
    .drag-handle {
      width: 40px;
      height: 5px;
      background: var(--surface-lighter);
      border-radius: 2.5px;
      margin-bottom: 16px;
      cursor: grab;
    }

    .input-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--text-light);
      text-align: center;
    }

    .input-subtitle {
      font-size: 0.875rem;
      color: rgba(255,255,255,0.7);
      text-align: center;
      max-width: 400px;
    }
    
    .accordion-content {
      flex: 1;
      overflow-y: auto;
      width: 100%;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }
    
    .input-panel {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      max-width: 740px;
      margin: 0 auto;
    }
    
    .face-input {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 4px;
      padding: 12px;
      border-radius: var(--radius-md);
      position: relative;
      transition: var(--transition);
      box-shadow: var(--shadow);
    }

    .face-input::before {
      content: attr(data-face-name);
      position: absolute;
      top: -16px;
      left: 0;
      right: 0;
      text-align: center;
      font-weight: 500;
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 1px;
      color: rgba(255,255,255,0.8);
    }
    
    .face-input input {
      width: 100%;
      height: 100%;
      font-size: 1.25rem;
      text-align: center;
      border: none;
      border-radius: var(--radius-sm);
      outline: none;
      caret-color: white;
      color: var(--text-dark);
      background-color: rgba(255,255,255,0.9);
      transition: var(--transition);
      font-family: 'Rubik', sans-serif;
    }
    
    .face-input input:focus {
      transform: scale(1.05);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.5);
    }

    .action-buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      width: 100%;
      max-width: 600px;
      padding: 16px;
      border-top: 1px solid var(--surface-light);
      background-color: var(--surface);
    }

    .action-button {
      padding: 12px;
      font-size: 1rem;
      border: none;
      border-radius: var(--radius-md);
      background-color: var(--surface-light);
      font-family: "Rubik", sans-serif;
      font-weight: 500;
      color: var(--text-light);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .action-button-primary {
      background-color: var(--primary);
    }
    
    .action-button:hover {
      background-color: var(--surface-lighter);
      transform: translateY(-2px);
    }

    .action-button-primary:hover {
      background-color: var(--primary-dark);
    }

    .material-symbols-outlined {
      font-size: 24px;
    }

    .tutorial-panel {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 500px;
      background-color: var(--surface);
      color: var(--text-light);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-lg);
      z-index: 20;
      display: flex;
      flex-direction: column;
    }

    .tutorial-header {
      background-color: var(--secondary);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .tutorial-title {
      font-weight: 600;
      font-size: 1rem;
    }

    .tutorial-content {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .tutorial-step {
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .tutorial-desc {
      font-size: 0.875rem;
      line-height: 1.5;
      color: rgba(255,255,255,0.8);
    }

    .tutorial-nav {
      display: flex;
      justify-content: space-between;
      padding: 12px 16px;
      border-top: 1px solid var(--surface-light);
    }

    .tutorial-button {
      background-color: transparent;
      border: none;
      color: var(--text-light);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'Rubik', sans-serif;
      font-size: 0.875rem;
      padding: 8px 12px;
      border-radius: var(--radius-sm);
      transition: var(--transition);
    }

    .tutorial-button:hover {
      background-color: var(--surface-light);
    }

    /* Mobile Styles */
    @media (max-width: 768px) {
      .header h1 {
        font-size: 3rem;
      }
      
      .input-wrapper.open {
        height: 85vh;
      }
      
      .face-input {
        grid-template-columns: repeat(3, 40px);
        grid-template-rows: repeat(3, 40px);
      }
      
      .action-buttons {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Landscape mobile */
    @media (max-height: 500px) and (orientation: landscape) {
      .input-wrapper.open {
        height: 90vh;
      }
      
      .input-panel {
        gap: 16px;
      }
      
      .face-input {
        grid-template-columns: repeat(3, 32px);
        grid-template-rows: repeat(3, 32px);
        padding: 8px;
      }
      
      .face-input input {
        font-size: 1rem;
      }
    }

    /* Large screens */
    @media (min-width: 1200px) {
      .header h1 {
        font-size: 6rem;
      }
      
      .face-input {
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(3, 60px);
      }
    }
  </style>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
        "three/examples/jsm/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js",
        "three/examples/jsm/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
        "three/examples/jsm/geometries/RoundedBoxGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/RoundedBoxGeometry.js",
        "npm/@tweenjs/tween.js@20.0.0/dist/tween.esm.js": "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@20.0.0/dist/tween.esm.js"
      }
    }
  </script>
</head>
<body>
  <!-- 3D Canvas automatically created by Three.js -->

  <div class="header">
    <h1>SCUBIK</h1>
    <div class="buttons">
      <button class="button" id="resetButton">
        <span class="material-symbols-outlined">restart_alt</span>
        Reset
      </button>
      <button class="button" id="toggleGuideButton" style="display:none">
        <span class="material-symbols-outlined">help_outline</span>
        Guide
      </button>
      <button class="button" id="shuffleButton">
        <span class="material-symbols-outlined">shuffle</span>
        Shuffle
      </button>
      <button class="button button-primary" id="generateLinkButton">
        <span class="material-symbols-outlined">share</span>
        Share
      </button>
    </div>
  </div>

  <button class="input-panel-toggle" id="toggleInputPanel">
    <span class="material-symbols-outlined">text_fields</span>
    Customize&nbsp;Cube
  </button>

  <div class="input-wrapper" id="inputWrapper">
    <div class="input-header">
      <div class="drag-handle" id="dragHandle"></div>
      <h2 class="input-title">Scribe your message</h2>
      <p class="input-subtitle">Enter characters on each face of the cube to create your secret message</p>
    </div>
    
    <div class="accordion-content" id="accordionContent">
      <div class="input-panel">
        <div class="face-input" style="background-color: var(--cube-red);" data-face="front" data-face-name="Front">
          <input type="text" maxlength="1" id="front-0" />
          <input type="text" maxlength="1" id="front-1" />
          <input type="text" maxlength="1" id="front-2" />
          <input type="text" maxlength="1" id="front-3" />
          <input type="text" maxlength="1" id="front-4" />
          <input type="text" maxlength="1" id="front-5" />
          <input type="text" maxlength="1" id="front-6" />
          <input type="text" maxlength="1" id="front-7" />
          <input type="text" maxlength="1" id="front-8" />
        </div>
        
        <div class="face-input" style="background-color: var(--cube-blue);" data-face="right" data-face-name="Right">
          <input type="text" maxlength="1" id="right-0" />
          <input type="text" maxlength="1" id="right-1" />
          <input type="text" maxlength="1" id="right-2" />
          <input type="text" maxlength="1" id="right-3" />
          <input type="text" maxlength="1" id="right-4" />
          <input type="text" maxlength="1" id="right-5" />
          <input type="text" maxlength="1" id="right-6" />
          <input type="text" maxlength="1" id="right-7" />
          <input type="text" maxlength="1" id="right-8" />
        </div>
        
        <div class="face-input" style="background-color: var(--cube-orange);" data-face="back" data-face-name="Back">
          <input type="text" maxlength="1" id="back-0" />
          <input type="text" maxlength="1" id="back-1" />
          <input type="text" maxlength="1" id="back-2" />
          <input type="text" maxlength="1" id="back-3" />
          <input type="text" maxlength="1" id="back-4" />
          <input type="text" maxlength="1" id="back-5" />
          <input type="text" maxlength="1" id="back-6" />
          <input type="text" maxlength="1" id="back-7" />
          <input type="text" maxlength="1" id="back-8" />
        </div>
        
        <div class="face-input" style="background-color: var(--cube-coral);" data-face="left" data-face-name="Left">
          <input type="text" maxlength="1" id="left-0" />
          <input type="text" maxlength="1" id="left-1" />
          <input type="text" maxlength="1" id="left-2" />
          <input type="text" maxlength="1" id="left-3" />
          <input type="text" maxlength="1" id="left-4" />
          <input type="text" maxlength="1" id="left-5" />
          <input type="text" maxlength="1" id="left-6" />
          <input type="text" maxlength="1" id="left-7" />
          <input type="text" maxlength="1" id="left-8" />
        </div>
        
        <div class="face-input" style="background-color: var(--cube-white);" data-face="top" data-face-name="Top">
          <input type="text" maxlength="1" id="top-0" />
          <input type="text" maxlength="1" id="top-1" />
          <input type="text" maxlength="1" id="top-2" />
          <input type="text" maxlength="1" id="top-3" />
          <input type="text" maxlength="1" id="top-4" />
          <input type="text" maxlength="1" id="top-5" />
          <input type="text" maxlength="1" id="top-6" />
          <input type="text" maxlength="1" id="top-7" />
          <input type="text" maxlength="1" id="top-8" />
        </div>
        
        <div class="face-input" style="background-color: var(--cube-yellow);" data-face="bottom" data-face-name="Bottom">
          <input type="text" maxlength="1" id="bottom-0" />
          <input type="text" maxlength="1" id="bottom-1" />
          <input type="text" maxlength="1" id="bottom-2" />
          <input type="text" maxlength="1" id="bottom-3" />
          <input type="text" maxlength="1" id="bottom-4" />
          <input type="text" maxlength="1" id="bottom-5" />
          <input type="text" maxlength="1" id="bottom-6" />
          <input type="text" maxlength="1" id="bottom-7" />
          <input type="text" maxlength="1" id="bottom-8" />
        </div>
      </div>
    </div>
    
    <div class="action-buttons">
      <button class="action-button" id="resetTextButton">
        <span class="material-symbols-outlined">clear_all</span>
        Clear Text
      </button>
      <button class="action-button action-button-primary" id="applyTextButton">
        <span class="material-symbols-outlined">done_all</span>
        Apply to Cube
      </button>
    </div>
  </div>

  <div class="tutorial-panel" id="tutorialPanel" style="display: none;">
    <div class="tutorial-header">
      <div class="tutorial-title">Cube Solving Guide</div>
      <button class="tutorial-button" id="closeTutorial">
        <span class="material-symbols-outlined">close</span>
      </button>
    </div>
    <div class="tutorial-content">
      <div>
        <div class="tutorial-step">Step <span id="tutorialStepNumber">1</span>/7</div>
        <div class="tutorial-desc" id="tutorialText">
          Create the white cross. Find the white edge pieces and position them correctly around the white center piece.
        </div>
      </div>
    </div>
    <div class="tutorial-nav">
      <button class="tutorial-button" id="prevStep">
        <span class="material-symbols-outlined">arrow_back</span>
        Previous
      </button>
      <button class="tutorial-button" id="nextStep">
        Next
        <span class="material-symbols-outlined">arrow_forward</span>
      </button>
    </div>
  </div>


<script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
  import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
  import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
  import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
  import TWEEN from 'npm/@tweenjs/tween.js@20.0.0/dist/tween.esm.js';

  let loadedFont = null;
  const fontLoader = new FontLoader();

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x404040)
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;
  controls.rotateSpeed = 0.5;
  
  const light = new THREE.AmbientLight(0xffffff, 1);
  scene.add(light);
  
  function animateLightIntensity(targetIntensity, duration = 500) {
    new TWEEN.Tween({ intensity: light.intensity })
      .to({ intensity: targetIntensity }, duration)
      .easing(TWEEN.Easing.Quadratic.Out)
      .onUpdate(function (obj) {
        light.intensity = obj.intensity;
      })
      .start();
  }
  
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight.position.set(1, 1, 1).normalize();
  scene.add(dirLight);
  
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  
  const rubikGroup = new THREE.Group();
  scene.add(rubikGroup);
  
  const cubes = [];
  const size = 1;
  const gap = 0.04;
  const offset = (size + gap);
  
  
  // ‚úÖ √Åtdolgozott karakterek: bet≈±k be√©p√≠t√©se a kock√°kba (csoportba)
  const letterMeshes = [];
  const faceOffsets = [
    { dir: new THREE.Vector3(1, 0, 0), idx: 0 },   // Right
    { dir: new THREE.Vector3(-1, 0, 0), idx: 1 },  // Left
    { dir: new THREE.Vector3(0, 1, 0), idx: 2 },   // Top
    { dir: new THREE.Vector3(0, -1, 0), idx: 3 },  // Bottom
    { dir: new THREE.Vector3(0, 0, 1), idx: 4 },   // Front
    { dir: new THREE.Vector3(0, 0, -1), idx: 5 },  // Back
  ];
  
  function createRubikCube() {
    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
  
          const cubeGroup = new THREE.Group();
  
          const geometry = new RoundedBoxGeometry(size, size, size, 4, 0.1);
          const faceMaterials = [];
  
          for (let i = 0; i < 6; i++) {
            faceMaterials.push(new THREE.MeshPhongMaterial({ color: 0x101010, transparent: true, opacity: 1, emissive: 0x000000 }));
          }
  
          if (x === 1) faceMaterials[0] = new THREE.MeshPhongMaterial({ color: 0x4169E1, transparent: true, opacity: 1, emissive: 0x000000 });
          if (x === -1) faceMaterials[1] = new THREE.MeshPhongMaterial({ color: 0xFF7F50, transparent: true, opacity: 1, emissive: 0x000000 });
          if (y === 1) faceMaterials[2] = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 1, emissive: 0x000000 });
          if (y === -1) faceMaterials[3] = new THREE.MeshPhongMaterial({ color: 0xFFD700, transparent: true, opacity: 1, emissive: 0x000000 });
          if (z === 1) faceMaterials[4] = new THREE.MeshPhongMaterial({ color: 0xDC143C, transparent: true, opacity: 1, emissive: 0x000000 });
          if (z === -1) faceMaterials[5] = new THREE.MeshPhongMaterial({ color: 0xff6700, transparent: true, opacity: 1, emissive: 0x000000 });
  
          const cubeMesh = new THREE.Mesh(geometry, faceMaterials);
          cubeGroup.add(cubeMesh);
  
          cubeGroup.position.set(x * offset, y * offset, z * offset);
          cubeGroup.userData.originalPosition = { x, y, z };
          cubeGroup.userData.logicalPosition = { x, y, z };
          cubeGroup.userData.isRubikCube = true;
          cubes.push(cubeGroup);
          rubikGroup.add(cubeGroup);
        }
      }
    }
  }

  function applyFaceLetters(faceData = {}) {
    if (!loadedFont) return;

      // üî• Kor√°bbi bet≈±k t√∂rl√©se
      cubes.forEach(cube => {
        const toRemove = cube.children.filter(child => child.type === "Group");
        toRemove.forEach(child => cube.remove(child));
      });


    const sideKeys = ["right", "left", "top", "bottom", "front", "back"];
    const faceCharMap = sideKeys.map(k => (faceData[k] || " ".repeat(9)).padEnd(9).slice(0, 9).split(""));
  
    const textOptions = {
      font: loadedFont,
      size: 0.3,
      height: 0,
      curveSegments: 12,
      bevelEnabled: true,
      bevelThickness: 0.01,
      bevelSize: 0.01,
      bevelOffset: 0,
      bevelSegments: 1
    };
  
    cubes.forEach(cube => {
      const { x: gridX, y: gridY, z: gridZ } = cube.userData.originalPosition;

  
      faceOffsets.forEach(({ dir, idx }) => {
        const threshold = 0.2;
        if (Math.abs(dir.x) > 0 && Math.abs(gridX - dir.x) > threshold) return;
        if (Math.abs(dir.y) > 0 && Math.abs(gridY - dir.y) > threshold) return;
        if (Math.abs(dir.z) > 0 && Math.abs(gridZ - dir.z) > threshold) return;
  
        const toIndex = v => v === -1 ? 0 : v === 0 ? 1 : 2;
        let row = -1, col = -1;
        switch (idx) {
          case 0: row = toIndex(-gridY); col = 2 - toIndex(gridZ); break;   // Right (t√ºkr√∂zve)
          case 1: row = toIndex(-gridY); col = 2 - toIndex(-gridZ); break;  // Left (t√ºkr√∂zve)
          case 2: row = toIndex(gridZ); col = toIndex(gridX); break;
          case 3: row = toIndex(-gridZ);  col = toIndex(gridX); break;
          case 4: row = toIndex(-gridY); col = toIndex(gridX); break;
          case 5: row = toIndex(-gridY); col = toIndex(-gridX); break;
        }
  
        if (row < 0 || row > 2 || col < 0 || col > 2) return;
        const charIndex = row * 3 + col;
        const faceChar = faceCharMap[idx][charIndex];
        if (!faceChar || faceChar === " ") return;
  
        const textGeo = new TextGeometry(faceChar, textOptions);
        const textMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const textMesh = new THREE.Mesh(textGeo, textMat);
  
        const sideNormal = dir;
        //const worldPos = new THREE.Vector3(0, 0, 0).add(sideNormal.clone().multiplyScalar(size / 2 + 0.00));
        //textGeo.computeBoundingBox();
        //const textSize = textGeo.boundingBox.getSize(new THREE.Vector3());
        //const centerOffset = new THREE.Vector3(-textSize.x / 2, -textSize.y / 2, -textSize.z / 2);
        //textMesh.position.copy(worldPos.clone().add(centerOffset));
        //textMesh.position.addScaledVector(sideNormal, 0);

        textGeo.computeBoundingBox();
        const center = textGeo.boundingBox.getCenter(new THREE.Vector3());
        
        // ‚¨áÔ∏è Bet≈± k√∂zep√©nek eltol√°sa az orig√≥ra
        textMesh.position.set(0, 0, 0).sub(center);


        // √öj poz√≠ci√≥ √©s forgat√°s be√°ll√≠t√°s oldalank√©nt
        switch (idx) {
          case 0: // Right (+X)
            textMesh.rotation.set(0, Math.PI / 2, 0);
            textMesh.position.set(0.5, -0.1, 0.1);
            break;
          case 1: // Left (-X)
            textMesh.rotation.set(0, -Math.PI / 2, 0);
            textMesh.position.set(-0.5, -0.1, -0.1);
            break;
          case 2: // Top (+Y)
            textMesh.rotation.set(-Math.PI / 2, 0, 0);
            textMesh.position.set(-0.1, 0.5, 0.1);
            break;
          case 3: // Bottom (-Y)
            textMesh.rotation.set(Math.PI / 2, 0, 0);
            textMesh.position.set(-0.1, -0.5 , -0.1);
            break;
          case 4: // Front (+Z)
            textMesh.rotation.set(0, 0, 0);
            textMesh.position.set(-0.1, -0.1, 0.5);
            break;
          case 5: // Back (-Z)
            textMesh.rotation.set(0, Math.PI, 0);
            textMesh.position.set(0.1, -0.1, -0.5);
            break;
        }
		
		// Finom m√©lys√©gi poz√≠ci√≥ a lap s√≠kj√°ra
        //textMesh.position.add(sideNormal.clone().multiplyScalar(0));

  
        const pivot = new THREE.Group();
        pivot.add(textMesh);
        
        // Poz√≠ci√≥ a lap s√≠kj√°ra
        pivot.position.copy(sideNormal.clone().multiplyScalar(0));
        cube.add(pivot);
      });
    });
  }
  
  
  
    
  fontLoader.load('RobotoMono.json', font => {
    loadedFont = font;
    initFromUrl().then(() => {
    if (!window.location.search.includes("c=")) {
      applyFaceLetters({
        front:  "SEND_YOUR",
        back:   "AAAAAAAAA",
        left:   "AAAAAAAAA",
        right:  "MESSAGES_",
        top:    "___SECRET",
        bottom: "CURIOUS??"
      });
    }
    if (window.location.search.includes('c=')) {
      const inputWrapper = document.getElementById('inputWrapper');
      inputWrapper.classList.remove('open');
      inputWrapper.style.height = '300px';
      currentHeight = 300;
    }
    });
  });
  
  
    function updateLogicalPositions() {
    cubes.forEach(cube => {
      cube.userData.logicalPosition = {
        x: Math.round(cube.position.x / offset),
        y: Math.round(cube.position.y / offset),
        z: Math.round(cube.position.z / offset)
      };
    });
  }
   

  
  function highlightStep(stepIndex) {
    if (!guideEnabled) {
      animateLightIntensity(4);
      cubes.forEach(cube => {
        cube.children[0].material.forEach(mat => {
          mat.emissive.set(0x000000);
          mat.opacity = 1;
        });
      });
      return;
    }
  
  
  
    animateLightIntensity(4);
    cubes.forEach(cube => {
      cube.children[0].material.forEach(mat => {
        mat.emissive.set(0x000000);
        mat.opacity = 0.5;
      });
    });
  
    let targets = [];
	const useOriginal = stepIndex <= 20;
  
    if (stepIndex === 0) { // k√∂z√©pkock√°k
      targets = cubes.filter(cube => {
        const pos = useOriginal ? cube.userData.originalPosition : cube.userData.logicalPosition;
        return (pos.x === 0 && pos.y !== 0 && pos.z === 0) ||
               (pos.x === 0 && pos.y === 0 && pos.z !== 0) ||
               (pos.x !== 0 && pos.y === 0 && pos.z === 0);
      });
    }
    else if (stepIndex === 1) { // √©lkock√°k
      targets = cubes.filter(cube => {
        const pos = useOriginal ? cube.userData.originalPosition : cube.userData.logicalPosition;
        return (Math.abs(pos.x) + Math.abs(pos.y) + Math.abs(pos.z)) === 2;
      });
    }
    else if (stepIndex === 2) { // sarokkock√°k
      targets = cubes.filter(cube => {
        const pos = useOriginal ? cube.userData.originalPosition : cube.userData.logicalPosition;
        return (Math.abs(pos.x) + Math.abs(pos.y) + Math.abs(pos.z)) === 3;
      });
    }
    else if (stepIndex === 3) { // fels≈ë r√©teg (U)
      const maxY = Math.max(...cubes.map(cube => cube.position.y));
      targets = cubes.filter(cube => Math.abs(cube.position.y - maxY) < 0.2);
    }
    else if (stepIndex === 4) { // als√≥ r√©teg (D)
      const minY = Math.min(...cubes.map(cube => cube.position.y));
      targets = cubes.filter(cube => Math.abs(cube.position.y - minY) < 0.2);
    }
    else if (stepIndex === 5) { // jobb oldal (R)
      const maxX = Math.max(...cubes.map(cube => cube.position.x));
      targets = cubes.filter(cube => Math.abs(cube.position.x - maxX) < 0.2);
    }
    else if (stepIndex === 6) { // bal oldal (L)
      const minX = Math.min(...cubes.map(cube => cube.position.x));
      targets = cubes.filter(cube => Math.abs(cube.position.x - minX) < 0.2);
    }
    else if (stepIndex === 7) { // front oldal (F)
      const maxZ = Math.max(...cubes.map(cube => cube.position.z));
      targets = cubes.filter(cube => Math.abs(cube.position.z - maxZ) < 0.2);
    }
    else if (stepIndex === 8) { // feh√©r kereszt
      targets = cubes.filter(cube => {
        const pos = useOriginal ? cube.userData.originalPosition : cube.userData.logicalPosition;
        return (pos.y === 1) && (pos.x === 0 || pos.z === 0);
      });
    }
    else if (stepIndex === 9) { // feh√©r sarkok
      targets = cubes.filter(cube => {
        const pos = useOriginal ? cube.userData.originalPosition : cube.userData.logicalPosition;
        return (pos.y === 1) && (pos.x !== 0) && (pos.z !== 0);
      });
    }
    // 11: Ford√≠tsd meg a kock√°t (nem kiemel semmit)
    // 12: √âl keres√©se (fels≈ë r√©teg, s√°rga n√©lk√ºl)
    else if (stepIndex === 12) {
      targets = cubes.filter(cube => {
        const pos = cube.userData.logicalPosition;
        const isEdge = (Math.abs(pos.x) + Math.abs(pos.y) + Math.abs(pos.z)) === 2;
        const isTop = pos.y === 1;
        const hasYellow = cube.material.some(mat => mat.color.getHexString() === 'ff6700');
        return isEdge && isTop && !hasYellow;
      });
    }
   
    // 13: √âl igaz√≠t√°sa (fels≈ë √©lkock√°k k√∂z√©pen)
    else if (stepIndex === 13) {
      targets = cubes.filter(cube => {
        const pos = cube.userData.logicalPosition;
        return pos.y === 1 && ((pos.x === 0 && pos.z !== 0) || (pos.z === 0 && pos.x !== 0));
      });
    }
   
    // 14: D√∂nt√©s: balra vagy jobbra (√∂sszes √©lkocka fel√ºl)
    else if (stepIndex === 14) {
      targets = cubes.filter(cube => {
        const pos = cube.userData.logicalPosition;
        const isEdge = (Math.abs(pos.x) + Math.abs(pos.y) + Math.abs(pos.z)) === 2;
        return pos.y === 1 && isEdge;
      });
    }
   
    // 15: Ism√©tl√©s ‚Äì fels≈ë √©lkock√°k √∫jra
    else if (stepIndex === 15) {
      targets = cubes.filter(cube => {
        const pos = cube.userData.logicalPosition;
        const isEdge = (Math.abs(pos.x) + Math.abs(pos.y) + Math.abs(pos.z)) === 2;
        return pos.y === 1 && isEdge;
      });
    }
  
    targets.forEach(cube => {
      cube.children[0].material.forEach(mat => {
        mat.emissive.set(0x444444);
        mat.opacity = 1;
      });
    });
  }

  createRubikCube();
  
  camera.position.set(4, 4, 6);
  controls.target.set(0, 0, 0);
  controls.update();
  
  
  async function initFromUrl() {
    const params = new URLSearchParams(window.location.search);
    const compressed = params.get('c');
    if (!compressed) return;
  
    try {
      const json = LZString.decompressFromEncodedURIComponent(compressed);
      if (!json) {
        console.error("Nem siker√ºlt dek√≥dolni a t√∂m√∂r√≠tett adatot.");
        return;
      }
  
      const decoded = JSON.parse(json);
  
      rubikGroup.visible = false;
      applyFaceLetters(decoded);
 
      // Azonnali forgat√°sok
      if (decoded.moves && Array.isArray(decoded.moves)) {
        for (const move of decoded.moves) {
          const layerFilter = cube => Math.abs(cube.position[move.axis] - move.layerValue) < 0.2;
          applyInstantRotation(layerFilter, move.axis, move.direction);
        }
        updateLogicalPositions();
      }
  
      rubikGroup.visible = true;
  
    } catch (e) {
      console.error("Hiba t√∂rt√©nt az URL adat visszafejt√©sekor:", e);
    }
  }
  
  function applyInstantRotation(layerFilter, axis, direction) {
    const selected = cubes.filter(layerFilter);
    const group = new THREE.Group();
    selected.forEach(cube => group.add(cube));
    rubikGroup.add(group);
  
    const angle = direction * Math.PI / 2;
    const rotMatrix = new THREE.Matrix4();
    if (axis === 'x') rotMatrix.makeRotationX(angle);
    if (axis === 'y') rotMatrix.makeRotationY(angle);
    if (axis === 'z') rotMatrix.makeRotationZ(angle);
  
    selected.forEach(cube => {
      cube.applyMatrix4(rotMatrix);
      cube.updateMatrixWorld(true);
      rubikGroup.add(cube); // vissza a f≈ëcsoportba
    });
  
    rubikGroup.remove(group);
    updateLogicalPositions();
  }
  
  
  const steps = [
    { title: "1: Az oldalak", desc: "Rubik-kocka oldalai: Feh√©r (fels≈ë), S√°rga (als√≥), Piros (el√ºls≈ë), Narancs (h√°ts√≥), K√©k (jobb), Z√∂ld (bal). Ezekhez viszony√≠tunk." },
    { title: "2: √âlkock√°k", desc: "K√©t sz√≠nt tartalmaz√≥ kock√°k, k√©t oldal tal√°lkoz√°s√°n√°l helyezkednek el." },
    { title: "3: Sarokkock√°k", desc: "H√°rom sz√≠nt tartalmaz√≥ kock√°k, a sarkokban helyezkednek el." },
    { title: "4: Up forgat√°s", desc: "Fels≈ë r√©teg forgat√°sa √≥ramut√≥ szerint (U) √©s ellent√©tesen (U')" },
    { title: "5: Down forgat√°s", desc: "Als√≥ r√©teg forgat√°sa √≥ramutat√≥ szerint (D) √©s ellent√©tesen (D')." },
    { title: "6: Right forgat√°s", desc: "Jobb oldali r√©teg forgat√°sa √≥ramutat√≥ szerint (R) √©s ellent√©tesen (R')" },
    { title: "7: Left forgat√°s", desc: "Bal oldali r√©teg forgat√°sa √≥ramutat√≥ szerint (L) √©s ellent√©tesen (L')" },
    { title: "8: Front forgat√°s", desc: "Az el√ºls≈ë (piros) oldal forgat√°sa az √≥ramutat√≥ j√°r√°s√°val megegyez≈ëen (F), vagy ellent√©tesen (F')." },
    { title: "9: Feh√©r kereszt", desc: "Keresd a feh√©r oldalt √©s a hozz√° tartoz√≥ √©lkock√°kat, pr√≥b√°ld √∫gy forgatni, hogy az √©lkock√°k feh√©r sz√≠ne a feh√©r oldalon legyen √©s m√°sik sz√≠ne megeggyezen a m√°sik oldallal." },
    { title: "10: Feh√©r sarkok", desc: "K√©t jobb oldali sarok (fels≈ë √©s als√≥) kicser√©l√©s√©re haszn√°ld az R' D' R D algoritmust. Ha kell forgasd a kock√°t, a v√©g√©re a 4 sarok legyen a hely√©n." },
    
    { title: "11: Ford√≠tsd meg a kock√°t", desc: "Mostant√≥l a s√°rga oldal legyen fel√ºl, √≠gy a k√∂z√©ps≈ë √©lek k√∂nnyen el√©rhet≈ëk lesznek." },
    { title: "12: Olyan √©lkocka keres√©se", desc: "Keresd a fels≈ë r√©tegben azokat az √©lkock√°kat, amelyek nem tartalmaznak s√°rga sz√≠nt." },
    { title: "13: Igaz√≠t√°s a sz√≠nhez", desc: "Forgasd a fels≈ë r√©teget √∫gy, hogy az √©lkocka egyik sz√≠ne megegyezzen a k√∂z√©ps≈ë r√©teg k√∂z√©ps≈ë sz√≠n√©vel (a megfelel≈ë oldal√°n)." },
    { title: "14: D√∂nt√©s: balra vagy jobbra", desc: "N√©zd meg, hogy az √©l m√°sik sz√≠ne melyik oldalon van. Ha balra kell helyezni: U' L' U L U F U' F'. Ha jobbra: U R U' R' U' F' U F." },
    { title: "15: Ism√©tl√©s m√°s √©lekre", desc: "Ism√©teld meg a fenti l√©p√©seket minden olyan √©lkock√°n√°l, amely nem tartalmaz s√°rg√°t √©s m√©g nincs hely√©n." },
    
    { title: "16: S√°rga kereszt", desc: "Haszn√°ld a F R U R' U' F' algoritmust a s√°rga alakzat kialak√≠t√°s√°hoz a fels≈ë oldalon." },
    { title: "17: S√°rga sarkok helyre t√©tele", desc: "Haszn√°ld az U R U' L' U R' U' L algoritmust." },
    { title: "18: S√°rga sarkok elforgat√°sa", desc: "R' D' R D t√∂bbsz√∂r ism√©telve minden sarokn√°l." },
    { title: "19: Fels≈ë √©lkock√°k elforgat√°sa", desc: "Haszn√°ld a F2 U L R' F2 L' R U F2 algoritmust a teljes kirak√°shoz." }
  ];

  let currentStep = 0;

  // Friss√≠tj√ºk updateTutorial f√ºggv√©nyt
  function updateTutorial() {
    const text = document.getElementById("tutorialText");
    text.innerHTML = `<strong>${steps[currentStep].title}</strong>${steps[currentStep].desc}`;
    highlightStep(currentStep);
    //createFancyArrowForStep(currentStep);
  }

  document.getElementById("prevStep").addEventListener("click", () => {
    if (currentStep > 0) {
      currentStep--;
      updateTutorial();
    }
  });

  document.getElementById("nextStep").addEventListener("click", () => {
    if (currentStep < steps.length - 1) {
      currentStep++;
      updateTutorial();
    }
  });
  
  document.getElementById('toggleGuideButton').addEventListener('click', () => {
  guideEnabled = !guideEnabled;

  const tutorialPanel = document.querySelector('.tutorial-panel');
  if (guideEnabled) {
    tutorialPanel.style.display = 'flex';
  } else {
    tutorialPanel.style.display = 'none';
    cubes.forEach(cube => {
      cube.children[0].material.forEach(mat => {
        mat.emissive.set(0x000000);
        mat.opacity = 1;
      });
      });
    }

  updateTutorial(); // hogy r√∂gt√∂n friss√ºlj√∂n a megjelen√©s is
  });
  
  let guideEnabled = false;
  let selectedCube = null;
  let selectedFaceNormal = null;
  let selectedLocalRight = null;
  let selectedLocalUp = null;
  let isDragging = false;
  let dragStart = new THREE.Vector2();
  let moveHistory = [];
  
  function onPointerDown(x, y) {
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;
  
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(cubes);
  
    if (intersects.length > 0) {
      selectedCube = intersects[0].object.parent;
      selectedFaceNormal = intersects[0].face.normal.clone().applyMatrix3(new THREE.Matrix3().getNormalMatrix(selectedCube.matrixWorld)).normalize();
  
      const globalUp = new THREE.Vector3(0, 1, 0);
  
      if (Math.abs(selectedFaceNormal.x) > 0.9) {
        selectedLocalRight = new THREE.Vector3(0, 0, selectedFaceNormal.x > 0 ? -1 : 1);
        selectedLocalUp = new THREE.Vector3(0, 1, 0);
      } else if (Math.abs(selectedFaceNormal.y) > 0.9) {
        selectedLocalRight = new THREE.Vector3(1, 0, 0);
        selectedLocalUp = new THREE.Vector3(0, 0, selectedFaceNormal.y > 0 ? -1 : 1);
      } else {
        selectedLocalRight = new THREE.Vector3(1, 0, 0);
        selectedLocalUp = new THREE.Vector3(0, 1, 0);
      }
  
      dragStart.set(x, y);
      isDragging = true;
      controls.enabled = false;
    }
  }
  
    function onPointerUp(x, y) {
    if (!isDragging || !selectedCube || !selectedFaceNormal) {
      controls.enabled = true;
      return;
    }
  
    const dragEnd = new THREE.Vector2(x, y);
    const dragVector = new THREE.Vector2().subVectors(dragEnd, dragStart);
  
    if (dragVector.length() > 5) {
      const moveVector = new THREE.Vector2(dragVector.x, -dragVector.y);
      let rightAmount, upAmount;
      let axis, layerFilter, direction;
      let layerValue;
  
      if (Math.abs(selectedFaceNormal.z) > 0.9) {
        // FRONT/BACK
        rightAmount = moveVector.x;
        upAmount = moveVector.y;
  
        if (Math.abs(rightAmount) > Math.abs(upAmount)) {
          // Jobbra/Balra h√∫z√°s
          layerFilter = cube => Math.abs(cube.position.y - selectedCube.position.y) < 0.2;
          axis = 'y';
          direction = selectedFaceNormal.z > 0
            ? (rightAmount > 0 ? 1 : -1)
            : (rightAmount > 0 ? 1 : -1);
			layerValue = nearestLayerValue(selectedCube.position, axis);
        } else {
          // Fel/Le h√∫z√°s
          layerFilter = cube => Math.abs(cube.position.x - selectedCube.position.x) < 0.2;
          axis = 'x';
          direction = selectedFaceNormal.z > 0
            ? (upAmount > 0 ? -1 : 1)
            : (upAmount > 0 ? 1 : -1);
			layerValue = nearestLayerValue(selectedCube.position, axis);
        }
      } else if (Math.abs(selectedFaceNormal.x) > 0.9) {
        // LEFT/RIGHT
        rightAmount = moveVector.x;
        upAmount = moveVector.y;
  
        if (Math.abs(rightAmount) > Math.abs(upAmount)) {
          // Jobbra/Balra h√∫z√°s
          layerFilter = cube => Math.abs(cube.position.y - selectedCube.position.y) < 0.2;
          axis = 'y';
          direction = selectedFaceNormal.x > 0
            ? (rightAmount > 0 ? 1 : -1)
            : (rightAmount > 0 ? 1 : -1);
			layerValue = nearestLayerValue(selectedCube.position, axis);
        } else {
          // Fel/Le h√∫z√°s
          layerFilter = cube => Math.abs(cube.position.z - selectedCube.position.z) < 0.2;
          axis = 'z';
          direction = selectedFaceNormal.x > 0
            ? (upAmount > 0 ? 1 : -1)
            : (upAmount > 0 ? -1 : 1);
			layerValue = nearestLayerValue(selectedCube.position, axis);
        }
      } else if (Math.abs(selectedFaceNormal.y) > 0.9) {
        // TOP/BOTTOM
        rightAmount = moveVector.x;
        upAmount = moveVector.y;
  
        if (Math.abs(rightAmount) > Math.abs(upAmount)) {
          // Jobbra/Balra h√∫z√°s
          layerFilter = cube => Math.abs(cube.position.z - selectedCube.position.z) < 0.2;
          axis = 'z';
          direction = selectedFaceNormal.y > 0
            ? (rightAmount > 0 ? -1 : 1)
            : (rightAmount > 0 ? 1 : -1);
			layerValue = nearestLayerValue(selectedCube.position, axis);
        } else {
          // Fel/Le h√∫z√°s
          layerFilter = cube => Math.abs(cube.position.x - selectedCube.position.x) < 0.2;
          axis = 'x';
          direction = selectedFaceNormal.y > 0
            ? (upAmount > 0 ? -1 : 1)
            : (upAmount > 0 ? -1 : 1);
			layerValue = nearestLayerValue(selectedCube.position, axis);
        }
      }
	  
	  
if (layerFilter && axis && direction !== undefined && layerValue !== undefined) {
  rotateLayer(layerFilter, axis, direction, layerValue);
    console.log("Forgat√°s.", { layerFilter, axis, direction, layerValue });

} else {
  console.warn("Forgat√°s kihagyva: valamelyik param√©ter hi√°nyzik.", { layerFilter, axis, direction, layerValue });
  controls.enabled = true;
}
}
  
    isDragging = false;
    selectedCube = null;
    selectedFaceNormal = null;
  };
   
    window.addEventListener('mousedown', (e) => {
    onPointerDown(e.clientX, e.clientY);
  });
  
  window.addEventListener('mouseup', (e) => {
    onPointerUp(e.clientX, e.clientY);
  });
  
  window.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      onPointerDown(e.touches[0].clientX, e.touches[0].clientY);
    }
  });
  
  window.addEventListener('touchend', (e) => {
    if (e.changedTouches.length === 1) {
      onPointerUp(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }
  });
  

  function rotateLayer(filterFunc, axis, direction, layerValue = null) {
    if (layerValue !== null) {
      moveHistory.push({ axis, direction, layerValue });
	  console.log("Forgat√°s mentve:", { axis, direction, layerValue });
    }
      return new Promise((resolve) => {
        const group = new THREE.Group();
        rubikGroup.add(group);
        const selected = cubes.filter(filterFunc);
        selected.forEach(cube => group.add(cube));
    
        const targetRotation = { x: group.rotation.x, y: group.rotation.y, z: group.rotation.z };
  	  
        if (axis === 'x') targetRotation.x += direction * Math.PI / 2;
        if (axis === 'y') targetRotation.y += direction * Math.PI / 2;
        if (axis === 'z') targetRotation.z += direction * Math.PI / 2;
    
        new TWEEN.Tween(group.rotation)
          .to(targetRotation, 500)
          .easing(TWEEN.Easing.Quadratic.Out)
          .onComplete(() => {
            selected.forEach(cube => {
              group.updateMatrixWorld();
              cube.applyMatrix4(group.matrix);
              rubikGroup.add(cube);
            });
            rubikGroup.remove(group);
            controls.enabled = true;
            resolve();
          })
          .start();
      });
  }

  function nearestLayerValue(position, axis) {
    const raw = position[axis];
    const options = [-1.04, 0, 1.04];
    return options.reduce((closest, val) =>
      Math.abs(val - raw) < Math.abs(closest - val) ? val : closest
    );
  }

  
  function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
  updateTutorial();
  document.querySelector('.tutorial-panel').style.display = 'none';

  
  document.getElementById('shuffleButton').addEventListener('click', () => {
    shuffleCube(20);
  });
  
  document.getElementById('resetButton').addEventListener('click', () => {
    resetCube();
  });
  
  async function shuffleCube(moves = 20) {
    const axes = ['x', 'y', 'z'];
    const layers = [-offset, 0, offset];
  
    for (let i = 0; i < moves; i++) {
      const axis = axes[Math.floor(Math.random() * axes.length)];
      const layerValue = [-1.04, 0, 1.04][Math.floor(Math.random() * 3)];
      const layerFilter = cube => Math.abs(cube.position[axis] - layerValue) < 0.2;
      const direction = Math.random() > 0.5 ? 1 : -1;
  
      await rotateLayer(layerFilter, axis, direction, layerValue);
      await new Promise(res => setTimeout(res, 100)); // Kis sz√ºnet, hogy szebb legyen
    }
	updateLogicalPositions();
  }

  function resetCube() {
    while (rubikGroup.children.length > 0) {
      const child = rubikGroup.children[0];
      rubikGroup.remove(child);
    }
    cubes.length = 0;
    moveHistory = [];
    createRubikCube();
	updateLogicalPositions();
  }
  
  document.getElementById('applyTextButton').addEventListener('click', () => {
    const getVal = id => {
  // ha a r√©gi mez≈ë l√©tezik (pl. face-front), haszn√°ld azt
  //const el = document.getElementById(id);
  //if (el) return el.value.padEnd(9).slice(0, 9);

  // ha nem, akkor pr√≥b√°ld √∂sszef≈±zni a 3√ó3 inputokb√≥l (pl. front-0...front-8)
  const face = id.replace('face-', '');
  let result = '';
  for (let i = 0; i < 9; i++) {
    const cell = document.getElementById(`${face}-${i}`);
    result += cell && cell.value ? cell.value : ' ';
  }
  return result.padEnd(9).slice(0, 9);
};
    applyFaceLetters({
      front:  getVal('face-front'),
      back:   getVal('face-back'),
      left:   getVal('face-left'),
      right:  getVal('face-right'),
      top:    getVal('face-top'),
      bottom: getVal('face-bottom')
    });
  });
  
  document.getElementById('generateLinkButton').addEventListener('click', () => {
    const getVal = id => {
  // ha a r√©gi mez≈ë l√©tezik (pl. face-front), haszn√°ld azt
  //const el = document.getElementById(id);
  //if (el) return el.value.padEnd(9).slice(0, 9);

  // ha nem, akkor pr√≥b√°ld √∂sszef≈±zni a 3√ó3 inputokb√≥l (pl. front-0...front-8)
  const face = id.replace('face-', '');
  let result = '';
  for (let i = 0; i < 9; i++) {
    const cell = document.getElementById(`${face}-${i}`);
    result += cell && cell.value ? cell.value : ' ';
  }
  return result.padEnd(9).slice(0, 9);
};
    const cubeState = {
      front: getVal('face-front'),
      back: getVal('face-back'),
      left: getVal('face-left'),
      right: getVal('face-right'),
      top: getVal('face-top'),
      bottom: getVal('face-bottom'),
      moves: moveHistory
    };
    const json = JSON.stringify(cubeState);
    const compressed = LZString.compressToEncodedURIComponent(json);
    const shareUrl = `${location.origin}${location.pathname}?c=${compressed}`;
    prompt("Copy this link:", shareUrl);
	console.log("Mentett moveHistory:", moveHistory);
  });
  
  document.querySelectorAll('.face-input').forEach((group, groupIndex, allGroups) => {
    const inputs = group.querySelectorAll('input');
    inputs.forEach((input, idx) => {
      input.addEventListener('input', e => {
        if (e.inputType !== 'deleteContentBackward' && input.value.length === 1) {
          if (idx < 8) {
            inputs[idx + 1].focus();
          } else {
            // Ugr√°s a k√∂vetkez≈ë csoport els≈ë mez≈ëj√©re
            const nextGroup = allGroups[groupIndex + 1];
            if (nextGroup) {
              const nextInput = nextGroup.querySelector('input');
              if (nextInput) nextInput.focus();
            }
          }
        }
      });
    });
  });
  
  
  const inputWrapper = document.getElementById('inputWrapper');
  const dragHandle = document.getElementById('dragHandle');

  let startY = 0;
  let startHeight = 0;
  let currentHeight = 100;
  let isDragging2 = false;
  
  const minHeight = 0;     // csak gombok
  const midHeight = 800;     // f√©lig
  const maxHeight = 1300; // teljesen nyitva
  
  dragHandle.addEventListener('mousedown', (e) => {
    isDragging2 = true;
    startY = e.clientY;
    startHeight = currentHeight;
    document.body.style.userSelect = 'none';
  });
  
  window.addEventListener('mousemove', (e) => {
    if (!isDragging2) return;
    const delta = startY - e.clientY;
    let newHeight = startHeight + delta;
    newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
    inputWrapper.style.height = `${newHeight}px`;
    currentHeight = newHeight;
  });
  
  window.addEventListener('mouseup', () => {
    if (!isDragging2) return;
    isDragging2 = false;
    document.body.style.userSelect = '';
  
    // snap to nearest state
    const distances = [minHeight, midHeight, maxHeight].map(h => Math.abs(currentHeight - h));
    const nearest = [minHeight, midHeight, maxHeight][distances.indexOf(Math.min(...distances))];
    inputWrapper.style.height = `${nearest}px`;
    currentHeight = nearest;
    if (nearest === minHeight) {
      inputWrapper.classList.remove('open');
    
      // v√°rj az anim√°ci√≥ v√©g√©ig, azt√°n rejtsd el
      setTimeout(() => {
        inputWrapper.style.display = 'none';
        toggleBtn.style.display = 'flex'; // gomb visszaj√∂n
      }, 850); // picit t√∂bb mint a CSS anim√°ci√≥ id≈ëtartama
    }
  });
  
  // Touch support
  dragHandle.addEventListener('touchstart', (e) => {
    isDragging2 = true;
    startY = e.touches[0].clientY;
    startHeight = currentHeight;
  }, { passive: true });
  
  window.addEventListener('touchmove', (e) => {
    if (!isDragging2) return;
    const delta = startY - e.touches[0].clientY;
    let newHeight = startHeight + delta;
    newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
    inputWrapper.style.height = `${newHeight}px`;
    currentHeight = newHeight;
  }, { passive: false });
  
  window.addEventListener('touchend', () => {
    if (!isDragging2) return;
    isDragging2 = false;
  
    const distances = [minHeight, midHeight, maxHeight].map(h => Math.abs(currentHeight - h));
    const nearest = [minHeight, midHeight, maxHeight][distances.indexOf(Math.min(...distances))];
    inputWrapper.style.height = `${nearest}px`;
    currentHeight = nearest;
    if (nearest === minHeight) {
      inputWrapper.classList.remove('open');
    
      // v√°rj az anim√°ci√≥ v√©g√©ig, azt√°n rejtsd el
      setTimeout(() => {
        inputWrapper.style.display = 'none';
        toggleBtn.style.display = 'flex'; // gomb visszaj√∂n
      }, 850); // picit t√∂bb mint a CSS anim√°ci√≥ id≈ëtartama
    }
  });
  
  const toggleBtn = document.getElementById('toggleInputPanel');
  
  toggleBtn.addEventListener('click', () => {
    inputWrapper.style.display = 'flex';
    inputWrapper.classList.add('open');
    inputWrapper.style.height = `${midHeight}px`;
    currentHeight = midHeight;
  
    toggleBtn.style.display = 'none'; // gomb elt≈±nik ha megnyitjuk a panelt
  });

  
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  
  
</script>
</body>
</html>